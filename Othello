import java.awt.AlphaComposite;
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Color;
import java.awt.Container;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.RenderingHints;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.awt.image.ImageObserver;
import java.io.File;
import java.io.IOException;
import java.util.Vector;

public class Othello implements ActionListener, MouseListener {
	//Standard Varaibles (ints, booleans, and strings)
	final int P1 = 0;
	final int P2 = 1;
	final int BLANK = 2;
	final Image NULL = null;
	String p1_name = "Player 1";
	String p2_name = "Player 2";
	String p1_score = "2";
	String p2_score = "2";
	String p1_pieces = " ";
	String p2_pieces = " ";
	String turn = " ";
	int p1_score_int; //All to be made into strings later
	int p2_score_int;
	int p1_pieces_int;
	int p2_pieces_int;
	int turn_int;
	boolean Green = true;
	boolean p2_human = false;
	static public ImageIcon blankpiece;
	static public ImageIcon p1piece;
	static public ImageIcon p2piece;
	static public ImageIcon p1preview;
	static public ImageIcon p2preview;
	//Frame Related Variables
	JFrame frame = new JFrame();
	JTextField P1name = new JTextField(p1_name);
	JLabel P1pieces = new JLabel(p1_pieces);
	JLabel P1score = new JLabel(p1_score);
	Container center = new Container();
	//Why do we have a south container? Discuss next class
	Container south = new Container();
	Container west = new Container();
	JTextField P2name = new JTextField(p2_name);
	JLabel P2pieces = new JLabel(p2_pieces);
	JLabel P2score = new JLabel(p2_score);
	JButton restart = new JButton("Restart");
	JButton P2drop_in = new JButton("Play against Human");
	JButton pass = new JButton("Pass");
	/*PieceIndicator P1indicator = new PieceIndicator();
	 * Out entirely optional stretch goals.
	 * Likely not needed but if we have extra time who knows.
	 * They will remain commented for now.
	PieceIndicator P2indicator = new PieceIndicator();*/
	JButton[][] board = new JButton[8][8];
	Piece[][] tiles = new Piece[8][8];
	JLabel Turn = new JLabel(turn);
	boolean valid = false;
	int p1scoreTemp = 0;
	int p2scoreTemp = 0;
	Vector<Piece> row = new Vector<Piece>();
	
	public Othello(){
		//Image blankimg = NULL;
		
		//p2preview.setImage(p2imgpre);
		frame.setSize(1280, 720);
		frame.setLayout(new BorderLayout());
		center.setLayout(new GridLayout(8, 8));
		for (int x = 0; x < board.length; x++)
		{
			for (int y = 0; y < board[0].length; y++)
			{
				board[x][y] = new JButton();
				tiles[x][y] = new Piece();
				tiles[x][y].setPlayer(BLANK);
				center.add(board[x][y]);
				board[x][y].addActionListener(this);
				board[x][y].addMouseListener(this);
			}
		}
		frame.add(center, BorderLayout.CENTER);
		west.setLayout(new GridLayout(6,1));
		west.add(P1name);
		west.add(P2name);
		west.add(P1score);
		P1score.setText(P1name.getText() + ": " + p1_score);
		west.add(P2score);
		P2score.setText(P2name.getText() + ": " + p2_score);
		west.add(restart);
		restart.addActionListener(this);
		west.add(pass);
		pass.addActionListener(this);
		west.add(P2drop_in);
		P2drop_in.addActionListener(this);
		frame.add(west, BorderLayout.WEST);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setVisible(true);
		//Set board color through hard reset
		reset();
		try 
		{
		Image blankimg = ImageIO.read(new File("Blank.png"));
		System.out.println(blankimg);
		//Image blankimgrs = blankimg.getScaledInstance(((int)(board[0][0].getSize().getWidth())), ((int)(board[0][0].getSize().getHeight())), Image.SCALE_SMOOTH);
		blankpiece = new ImageIcon(blankimg);
		} catch (IOException e) {
			e.printStackTrace();
		}
		//blankpiece.setImage(blankimg);
		//Image p1img = NULL;
		try 
		{
		Image p1img = ImageIO.read(new File("White_Piece.png"));
		Image p1imgrs = p1img.getScaledInstance(((int)(board[0][0].getSize().getWidth())), ((int)(board[0][0].getSize().getHeight())), Image.SCALE_SMOOTH);
		p1piece = new ImageIcon(p1imgrs);
		} catch (IOException e) {
			e.printStackTrace();
		}
		//p1piece.setImage(p1img);
		//Image p2img = NULL;
		try 
		{
		Image p2img = ImageIO.read(new File("Black_Piece.png"));
		Image p2imgrs = p2img.getScaledInstance(((int)(board[0][0].getSize().getWidth())), ((int)(board[0][0].getSize().getHeight())), Image.SCALE_SMOOTH);
		p2piece = new ImageIcon(p2imgrs);
		} catch (IOException e) {
			e.printStackTrace();
		}
		//p2piece.setImage(p2img);
		//Image p1imgpre = NULL;
		try 
		{
		Image p1imgpre = ImageIO.read(new File("White_Piece_Opaque.png"));
		Image p1imgprers = p1imgpre.getScaledInstance(((int)(board[0][0].getSize().getWidth())), ((int)(board[0][0].getSize().getHeight())), Image.SCALE_SMOOTH);
		p1preview = new ImageIcon(p1imgprers);
		} catch (IOException e) {
			e.printStackTrace();
		}
		//p1preview.setImage(p1imgpre);
		//Image p2imgpre = NULL;
		try 
		{
		Image p2imgpre = ImageIO.read(new File("Black_Piece_Opaque.png"));
		Image p2imgprers = p2imgpre.getScaledInstance(((int)(board[0][0].getSize().getWidth())), ((int)(board[0][0].getSize().getHeight())), Image.SCALE_SMOOTH);
		p2preview = new ImageIcon(p2imgprers);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) 
	{
		new Othello();

	}
	public void reset(){
		p1_score_int = 2;
		p2_score_int = 2;
		turn_int = 0;
		//Clear the board of all pieces
		for (int x = 0; x < board.length; x++)
		{
			if(Green == false)
			{
				Green = true;
			}
			else{
				Green = false;
			}
			for (int y = 0; y < board[0].length; y++) {
				if(Green == true){
					board[x][y].setBackground(Color.GREEN);
					board[x][y].setIcon(blankpiece);
					tiles[x][y].setPlayer(BLANK);
					Green = false;
				}
				else{
					board[x][y].setBackground(Color.WHITE);
					board[x][y].setIcon(blankpiece);
					tiles[x][y].setPlayer(BLANK);
					Green = true;
				}
				board[x][y].setEnabled(true);
			}
		}
		board[3][3].setIcon(p1piece);
		board[3][4].setIcon(p2piece);
		board[4][3].setIcon(p2piece);
		board[4][4].setIcon(p1piece);
		tiles[3][3].setPlayer(P1);
		tiles[3][4].setPlayer(P2);
		tiles[4][3].setPlayer(P2);
		tiles[4][4].setPlayer(P1);
	}
	public void textSet()
	{
		p1_score = Integer.toString(p1_score_int);
		p2_score = Integer.toString(p2_score_int);
		p1_pieces = Integer.toString(p1_pieces_int);
		p2_pieces = Integer.toString(p2_pieces_int);
		turn = Integer.toString(turn_int);
	}
	public int CountScores(int Player){
		p1scoreTemp = 0;
		p2scoreTemp = 0;
		for (int x = 0; x < tiles.length; x++) {
			for (int y = 0; y < tiles[x].length; y++) {
				if(tiles[x][y].getPlayer() == P1){
					board[x][y].setIcon(p1piece);
					p1scoreTemp++;
				}
				else if(tiles[x][y].getPlayer() == P2){
					board[x][y].setIcon(p2piece);
					p2scoreTemp++;
				}
			}
		}
		if(Player == P1){
			return p1scoreTemp;
		}
		else{
			return p2scoreTemp;
		}
	}
	public void check1(int x, int y) //Default check method. Checks from point A to the left.
	{
		/*
		 * OOOOO	OOOOO	OOOOO
		 * OOOOO	OOOOO	OOOOO
		 * OOOOO	OOOOO	OOOOO
		 * OXOOX	OX->X	OXXXX
		 * OOOOO    OOOOO	OOOOO
		 */
		row.clear();
		for(int a = x; a < tiles.length; a++)
		{
			if(tiles[a][y].getPlayer() != BLANK)
			{
				row.addElement(tiles[a][y]);
			}
			else
			{
				break;
			}
		}
		if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
		{
			for(int a = 0; a < row.size(); a++)
			{
				row.elementAt(a).setPlayer(turn_int);
			}
		}
	}
	public void check2(int x, int y) //2nd check method. Checks from point A to the right.
	{
		/*
		 * OOOOO	OOOOO	OOOOO
		 * OOOOO	OOOOO	OOOOO
		 * OOOOO	OOOOO	OOOOO
		 * OXOOX	OX<-X	OX<-X
		 * OOOOO    OOOOO	OOOOO
		 */
		row.clear();
		for(int a = x; a > -1; a--)
		{
			if(tiles[a][y].getPlayer() != BLANK)
			{
				row.addElement(tiles[a][y]);
			}
			else
			{
				break;
			}
		}
		if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
		{
			for(int a = 0; a < row.size(); a++)
			{
				row.elementAt(a).setPlayer(turn_int);
			}
		}
	}
	public void check3(int x, int y) //3rd check method. Checks from point A down.
	{
		/*
		 * OxOOO	OXOOO	OXOOO
		 * OOOOO	O|OOO	OXOOO
		 * OOOOO	OVOOO	OXOOO
		 * OXOOO	OXOOO	OXOOO
		 * OOOOO    OOOOO	OOOOO
		 */
		row.clear();
		for(int a = y; a < tiles[x].length; a++)
		{
			if(tiles[x][a].getPlayer() != BLANK)
			{
				row.addElement(tiles[x][a]);
			}
			else
			{
				break;
			}
		}
		if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
		{
			for(int a = 0; a < row.size(); a++)
			{
				row.elementAt(a).setPlayer(turn_int);
			}
		}
	}
	public void check4(int x, int y) //4th check method. Checks from point A up.
	{
		/*
		 * OxOOO	OXOOO	OXOOO
		 * OOOOO	O^OOO	OXOOO
		 * OOOOO	O|OOO	OXOOO
		 * OXOOO	OXOOO	OXOOO
		 * OOOOO    OOOOO	OOOOO
		 */
		row.clear();
		for(int a = y; a > -1; a--)
		{
			if(tiles[x][a].getPlayer() != BLANK)
			{
				row.addElement(tiles[x][a]);
			}
			else
			{
				break;
			}
		}
		if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
		{
			for(int a = 0; a < row.size(); a++)
			{
				row.elementAt(a).setPlayer(turn_int);
			}
		}
	}
	public void check5(int x, int y) //5th check method. Checks diagonally from point A down and to the right.
	{
		/*
		 * XOOOO	XOOOO	XOOOO
		 * OOOOO	O\OOO	OXOOO
		 * OOOOO	OO\OO	OOXOO
		 * OOOOO	OOO\O	OOOXO
		 * OOOOX    OOOOX	OOOOX
		 */
		if(x > y)
		{
			row.clear();
			for(int a = 0; a < tiles.length-x; a++)
			{
				if(tiles[x+a][y+a].getPlayer() != BLANK)
				{
					row.addElement(tiles[x+a][y+a]);
				}
				else
				{
					break;
				}
			}
			if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
			{
				for(int a = 0; a < row.size(); a++)
				{
					row.elementAt(a).setPlayer(turn_int);
				}
			}
		}
		else
		{
			row.clear();
			for(int a = 0; a < tiles[x].length-y; a++)
			{
				if(tiles[x+a][y+a].getPlayer() != BLANK)
				{
					row.addElement(tiles[x+a][y+a]);
				}
				else
				{
					break;
				}
			}
			if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
			{
				for(int a = 0; a < row.size(); a++)
				{
					row.elementAt(a).setPlayer(turn_int);
				}
			}
		}
	}
	public void check6(int x, int y) //6th check method. Checks diagonally from point A up and to the left.
	{
		/*
		 * XOOOO	XOOOO	XOOOO
		 * OOOOO	O\OOO	OXOOO
		 * OOOOO	OO\OO	OOXOO
		 * OOOOO	OOO\O	OOOXO
		 * OOOOX    OOOOX	OOOOX
		 */
		if(y > x)
		{
			row.clear();
			for(int a = 0; a < x; a++)
			{
				if(tiles[x-a][y-a].getPlayer() != BLANK)
				{
					row.addElement(tiles[x-a][y-a]);
				}
				else
				{
					break;
				}
			}
			if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
			{
				for(int a = 0; a < row.size(); a++)
				{
					row.elementAt(a).setPlayer(turn_int);
				}
			}
		}
		else
		{
			row.clear();
			for(int a = 0; a < y; a++)
			{
				if(tiles[x-a][y-a].getPlayer() != BLANK)
				{
					row.addElement(tiles[x-a][y-a]);
				}
				else
				{
					break;
				}
			}
			if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
			{
				for(int a = 0; a < row.size(); a++)
				{
					row.elementAt(a).setPlayer(turn_int);
				}
			}
		}
	}
	public void check7(int x, int y) //7th check method. Checks diagonally from point A down and to the left.
	{
		/*
		 * OOOOX	OOOOX	OOOOX
		 * OOOOO	OOO/O	OOOXO
		 * OOOOO	OO/OO	OOXOO
		 * OOOOO	O/OOO	OXOOO
		 * XOOOO    XOOOO	XOOOO
		 */
		if(x < 7-y)
		{
			row.clear();
			for(int a = 0; a < x; a++)
			{
				if(tiles[x-a][y+a].getPlayer() != BLANK)
				{
					row.addElement(tiles[x-a][y+a]);
				}
				else
				{
					break;
				}
			}
			if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
			{
				for(int a = 0; a < row.size(); a++)
				{
					row.elementAt(a).setPlayer(turn_int);
				}
			}
		}
		else
		{
			row.clear();
			for(int a = 0; a < 7-y; a++)
			{
				if(tiles[x-a][y+a].getPlayer() != BLANK)
				{
					row.addElement(tiles[x-a][y+a]);
				}
				else
				{
					break;
				}
			}
			if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
			{
				for(int a = 0; a < row.size(); a++)
				{
					row.elementAt(a).setPlayer(turn_int);
				}
			}
		}
	}
	public void check8(int x, int y) //8th check method. Checks diagonally from point A up and to the right
	{
		/*
		 * OOOOX	OOOOX	OOOOX
		 * OOOOO	OOO/O	OOOXO
		 * OOOOO	OO/OO	OOXOO
		 * OOOOO	O/OOO	OXOOO
		 * XOOOO    XOOOO	XOOOO
		 */
		if(x > y)
		{
			row.clear();
			for(int a = 0; a < 7-x; a++)
			{
				if(tiles[x+a][y+a].getPlayer() != BLANK)
				{
					row.addElement(tiles[x+a][y+a]);
				}
				else
				{
					break;
				}
			}
			if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
			{
				for(int a = 0; a < row.size(); a++)
				{
					row.elementAt(a).setPlayer(turn_int);
				}
			}
		}
		else
		{
			row.clear();
			for(int a = 0; a < 7-y; a++)
			{
				if(tiles[x+a][y+a].getPlayer() != BLANK)
				{
					row.addElement(tiles[x+a][y+a]);
				}
				else
				{
					break;
				}
			}
			if(row.size() != 0 && row.firstElement().getPlayer() == row.lastElement().getPlayer())
			{
				for(int a = 0; a < row.size(); a++)
				{
					row.elementAt(a).setPlayer(turn_int);
				}
			}
		}
	}
	public void actionPerformed(ActionEvent event) {
		if(event.getSource().equals(restart)){
			reset();
		}
		else if (event.getSource().equals(pass)){
			if(turn_int == P1){
				turn_int = P2;
			}
			else{
				turn_int = P1;
			}
		}
		else if(event.getSource().equals(P2drop_in))
		{
			if(p2_human == false)
			{
				p2_human = true;
			}
			else
			{
				p2_human = false;
			}
		}
		else{
			for (int x = 0; x < board.length; x++) {
				for (int y = 0; y < board[0].length; y++) {
					if(event.getSource().equals(board[x][y])){
						//Check if a valid move
						if(board[x][y].getIcon() == p1piece){
							//Invalid Move
						}
						else if(board[x][y].getIcon() == p2piece){
							//Invalid Move
						}
						else{
							tiles[x][y].setPlayer(turn_int);
							check1(x,y);
							check2(x,y);
							check3(x,y);
							check4(x,y);
							check5(x,y);
							check6(x,y);
							check7(x,y);
							check8(x,y);
							if(turn_int == P1){
								board[x][y].setIcon(p1piece);
								turn_int = P2;
							}
							else{
								board[x][y].setIcon(p2piece);
								turn_int = P1;
							}
						}
					}
				}
			}
		}
		p1_score_int = CountScores(P1);
		p2_score_int = CountScores(P2);
		textSet();
		//Update the points and names
		P1score.setText(P1name.getText() + ": " + p1_score);
		P2score.setText(P2name.getText() + ": " + p2_score);
		if(p2_human == false)
		{
			for(int x = 0; x < board.length; x++)
			{
				for(int y = 0; y < board[0].length; y++)
				{
					if(tiles[x][y].getPlayer() != BLANK)
					{
						if(x > 0 && tiles[x-1][y].getPlayer() == BLANK)
						{
							tiles[x-1][y].setPlayer(P2);
							board[x+1][y].setIcon(p2piece);
							check1(x-1,y);
							check2(x-1,y);
							check3(x-1,y);
							check4(x-1,y);
							check5(x-1,y);
							check6(x-1,y);
							check7(x-1,y);
							check8(x-1,y);
						}
						else if(x < 7 && tiles[x+1][y].getPlayer() == BLANK)
						{
							tiles[x+1][y].setPlayer(P2);
							board[x+1][y].setIcon(p2piece);
							check1(x+1,y);
							check2(x+1,y);
							check3(x+1,y);
							check4(x+1,y);
							check5(x+1,y);
							check6(x+1,y);
							check7(x+1,y);
							check8(x+1,y);
						}
						else if(y < 7 && tiles[x][y+1].getPlayer() == BLANK)
						{
							tiles[x][y+1].setPlayer(P2);
							board[x][y+1].setIcon(p2piece);
							check1(x,y+1);
							check2(x,y+1);
							check3(x,y+1);
							check4(x,y+1);
							check5(x,y+1);
							check6(x,y+1);
							check7(x,y+1);
							check8(x,y+1);
						}
						else if(y > 0 && tiles[x][y-1].getPlayer() == BLANK)
						{
							tiles[x][y-1].setPlayer(P2);
							board[x][y-1].setIcon(p2piece);
							check1(x,y-1);
							check2(x,y-1);
							check3(x,y-1);
							check4(x,y-1);
							check5(x,y-1);
							check6(x,y-1);
							check7(x,y-1);
							check8(x,y-1);
						}
						else if(y > 0 && x > 0 && tiles[x-1][y-1].getPlayer() == BLANK)
						{
							tiles[x-1][y-1].setPlayer(P2);
							board[x-1][y-1].setIcon(p2piece);
							check1(x-1,y-1);
							check2(x-1,y-1);
							check3(x-1,y-1);
							check4(x-1,y-1);
							check5(x-1,y-1);
							check6(x-1,y-1);
							check7(x-1,y-1);
							check8(x-1,y-1);
						}
						else if(y > 0 && x < 7 && tiles[x+1][y-1].getPlayer() == BLANK)
						{
							tiles[x+1][y-1].setPlayer(P2);
							board[x+1][y-1].setIcon(p2piece);
							check1(x+1,y-1);
							check2(x+1,y-1);
							check3(x+1,y-1);
							check4(x+1,y-1);
							check5(x+1,y-1);
							check6(x+1,y-1);
							check7(x+1,y-1);
							check8(x+1,y-1);
						}
						else if(y < 7 && x < 7 && tiles[x+1][y-1].getPlayer() == BLANK)
						{
							tiles[x+1][y+1].setPlayer(P2);
							board[x+1][y+1].setIcon(p2piece);
							check1(x+1,y+1);
							check2(x+1,y+1);
							check3(x+1,y+1);
							check4(x+1,y+1);
							check5(x+1,y+1);
							check6(x+1,y+1);
							check7(x+1,y+1);
							check8(x+1,y+1);
						}
					}
				}
			}
		}
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		//This method does nothing, but Eclipse throws a fit
		//If I don't have it
		
	}

	@Override
	public void mousePressed(MouseEvent e) {
		//This method does nothing, but Eclipse throws a fit
		//If I don't have it
		
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		//This method does nothing, but Eclipse throws a fit
		//If I don't have it
		
	}

	@Override
	public void mouseEntered(MouseEvent e)
	{
		for(int x = 0; x < board.length; x++)
		{
			for(int y = 0; y < board[0].length; y++)
			{
				if(e.getSource().equals(board[x][y]))
				{
					//Piece.drawPreview()
				}
			}
		}
	}

	@Override
	public void mouseExited(MouseEvent e) {
		for(int x = 0; x < board.length; x++)
		{
			for(int y = 0; y < board[0].length; y++)
			{
				if(e.getSource().equals(board[x][y]))
				{
					//Piece.cancelPreview()
				}
			}
		}
	}
}
